import { parse, relative, dirname, join, basename, resolve } from 'path';
import { existsSync, mkdirSync, readFileSync, appendFileSync, writeFileSync } from 'fs';
import { Pargv } from './';
import { IPargvCompletions, IPargvCompletionsConfig, IPargvCompletionPaths, IPargvParsedResult } from './interfaces';
import { IColurs } from 'colurs';
import { PARGV_ROOT, FLAG_EXP } from './constants';
import * as utils from './utils';
import { EOL } from 'os';

const srcTpl =  // template used to add to bash.
  `${EOL}${EOL}###-begin-{{app_name}}-completions-###${EOL}` +
  `source {{app_completions_path}}${EOL}` +
  `###-end-{{app_name}}-completions-###${EOL}`;


export function completions(pargv: Pargv): IPargvCompletions {

  const env = pargv._env;
  const colors = pargv.options.colors;
  const colurs = pargv._colurs;

  /**
   * Get Completion Paths
   * : Gets paths used for saving completions.
   *
   * @param path the path to the executable or file.
   */
  function getPaths(path: string): IPargvCompletionPaths {
    let appPath = path;
    if (/dev\/temp\.ts$/.test(path)) // hack used when debugging.
      appPath = 'pargv';
    const appName = basename(appPath); // get the basename from path.
    let completionsDir = join(env.HOME_PATH, `.${appName}`);
    if (/\.(ts|js)$/.test(appPath)) {
      appPath = `./${appPath}`; // not installed as bin.
      const parsedPath = parse(appPath);
      completionsDir = parsedPath.dir; // store completions.sh at executable file path.
    }
    let bashPath = !/^win/.test(env.PLATFORM) ? /^darwin/.test(env.PLATFORM) ? '.bash_profile' : '.bashrc' : false;
    if (bashPath)
      bashPath = join(env.HOME_PATH, bashPath);
    const completionsPath = join(completionsDir, 'completions.sh');
    return {
      appName,   // the base app name
      appPath,   // the executable app path.
      bashPath,   // the bash profile path.
      completionsDir,    // the directory to save completions.sh in.
      completionsPath // the completions path.
    };
  }

  /**
   * Generate
   * : Generates the completions.sh script.
   *
   * @param path the optional executable path.
   * @param command the optional reply command for completions.
   * @param template a custom template for generating completions.
   */
  function generate(path: string, command: string, template?: string): IPargvCompletionsConfig {
    const paths = getPaths(path);
    template = template || readFileSync(  // read in our script template.
      resolve(PARGV_ROOT, 'completion.sh.tpl'),
      'utf-8');
    template = template.replace(/{{app_name}}/g, paths.appName); // replace app name.
    template = template.replace(/{{app_reply_command}}/g, command); // replace the command.
    const script = template.replace(/{{app_path}}/g, paths.appPath); // replace the path.

    let sourceScript = srcTpl;
    sourceScript = sourceScript.replace(/{{app_name}}/g, paths.appName);
    sourceScript = sourceScript.replace(/{{app_completions_path}}/g, paths.completionsPath);

    return {
      paths,
      command,
      script,
      sourceScript
    };

  }

  /**
   * Ensure Dir
   * : Ensures the directory where completions.sh will be stored exists.
   * If it does not it creates it.
   *
   * @param dir the directory where the completions.sh file will be saved.
   */
  function ensureDir(dir: string) {
    try {
      if (!existsSync(dir))
        mkdirSync(dir);
      return true;
    }
    catch (ex) {
      return false;
    }
  }

  /**
   * Write
   * : Writes or appends script to file.
   *
   * @param path the path to write or append to.
   * @param script the script to be written or appended.
   * @param append when true append instead of write.
   */
  function write(path: string, script: string, append?: boolean) {
    try {
      if (append)
        appendFileSync(path, script, 'utf-8');
      else
        writeFileSync(path, script, 'utf-8');
      return true;
    }
    catch (ex) {
      return false;
    }
  }

  /**
   * Install
   * : Installs tab completions.sh and appends to bash.
   *
   * @param path the installation path typically generated by Pargv.
   * @param command an optional reply command name.
   * @param template the optional completions.sh template.
   * @param force when true ignore existing install and overwrites.
   */
  function install(path: string, command: string, template?: string, force?: boolean): boolean | IPargvCompletionsConfig {

    const gen = generate(path, command, template); // generate script and paths.

    if (existsSync(gen.paths.completionsPath) && force !== true) {
      pargv.error(
        pargv._localize(`completions already installed at %s, use --force to reinstall.`)
          .args(gen.paths.completionsPath)
          .styles(colors.accent)
          .done()
      );
      return;
    }

    if (!gen.paths.bashPath) { // failed to gen bash path probably windows.
      pargv.error(
        pargv._localize(`"cannot automatically install completions on platform %s.`)
          .args(pargv._env.PLATFORM)
          .styles(colors.accent)
          .done()
      );
      return;
    }

    const tmp = true;

    if (ensureDir(gen.paths.completionsDir)) {  // ensure dir exists.

      if (write(gen.paths.completionsPath, gen.script)) { // write out completion script.

        // const source = `source ${gen.paths.completionsPath}`;
        if (write(<string>gen.paths.bashPath, gen.sourceScript, true)) {  // append to profile.
          return gen; // return the successful configuration.
        }
        else {
          pargv.error(
            pargv._localize(`could not write, append or create path %s.`)
              .args(<string>gen.paths.bashPath)
              .styles(colors.accent)
              .done()
          );
        }

      }
      else {
        pargv.error(
          pargv._localize(`could not write, append or create path %s.`)
            .args(<string>gen.paths.completionsPath)
            .styles(colors.accent)
            .done()
        );
      }

    }
    else {
      pargv.error(
        pargv._localize(`could not write, append or create path %s.`)
          .args(<string>gen.paths.completionsDir)
          .styles(colors.accent)
          .done()
      );
    }

    return false; // return false to indicate install failed.

  }

  /**
   * Handler
   * : The completions handler returning found completions.
   *
   * @param current the current arg in the terminal
   * @param args the argv array.
   */
  function handler(current: string, argv: any[]) {

    let cmds = pargv._commands;
    let completions = [];

    if (pargv._env.EXEC === argv[0])
      argv.shift(); // remove first arg which is app/exec name.

    const tmpCmd = pargv.get.command(utils.first(argv)); // is first is known command.

    if (tmpCmd) { // limit to single command if known.

      cmds = {}; // set the commands to just the one known command.
      cmds[tmpCmd._name] = tmpCmd;

      const sliced = argv.slice(1); // remove command name.
      let curCmdIdx = 0;
      const lastCmdIdx = tmpCmd._commands.length - 1; // last index for commands.
      sliced.forEach((el, i) => {
        if (!FLAG_EXP.test(el) && i <= lastCmdIdx) {
          const prev = sliced[i - 1] || null;
          let prevKey = tmpCmd.isOption(prev);
          if (!prevKey && !FLAG_EXP.test(prev)) // could be val for option.
            curCmdIdx = i;
        }
      });

      const curIdx = sliced.length - 1;
      const prevIdx = sliced.length - 2;
      const prev = sliced[prevIdx] || null;
      const isFlagPrev = prev && FLAG_EXP.test(prev);
      const isBool = tmpCmd.isBool(prev);

      const isOption = isFlagPrev && !isBool;
      const isCommand =
        (curCmdIdx >= 0) &&
        (curCmdIdx <= lastCmdIdx);
      //  !FLAG_EXP.test(sliced[curIdx])

      if (isCommand || isOption) {
        const key = isOption ? tmpCmd.aliasToKey(prev) : tmpCmd.aliasToKey(curCmdIdx);
        if (tmpCmd._completions[key])
          completions = completions.concat(tmpCmd._completions[key]);
      }

      if (tmpCmd._completions['*']) // anon custom completions.
        completions = completions.concat(tmpCmd._completions['*']);

    }
    else {

      for (const k in cmds) { // iterate the commands/options and build completes.

        const cmd = cmds[k];

        [cmd._name].concat(cmd.aliases(cmd._name) || []) // iterate commands.
          .forEach((el, i) => {
            if (!~completions.indexOf(el))
              completions.push(el);
          });

        cmd._options.forEach((o) => {   // iterate options.
          if (!~completions.indexOf(o))
            completions.push(o);
          (cmd.aliases(o) || []).forEach((el) => {
            if (!~completions.indexOf(el))
              completions.push(el);
          });
        });

      }

    }

    return completions;

  }

  return {
    getPaths,
    generate,
    ensureDir,
    write,
    install,
    handler
  };

}


