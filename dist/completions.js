"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = require("path");
var fs_1 = require("fs");
var constants_1 = require("./constants");
var utils = require("./utils");
var os_1 = require("os");
var srcTpl = "" + os_1.EOL + os_1.EOL + "###-begin-{{app_name}}-completions-###" + os_1.EOL +
    ("source {{app_completions_path}}" + os_1.EOL) +
    ("###-end-{{app_name}}-completions-###" + os_1.EOL);
function completions(pargv) {
    var env = pargv._env;
    var colors = pargv.options.colors;
    var colurs = pargv._colurs;
    /**
     * Get Completion Paths
     * : Gets paths used for saving completions.
     *
     * @param path the path to the executable or file.
     */
    function getPaths(path) {
        var appPath = path;
        if (/dev\/temp\.ts$/.test(path))
            appPath = 'pargv';
        var appName = path_1.basename(appPath); // get the basename from path.
        var completionsDir = path_1.join(env.HOME_PATH, "." + appName);
        if (/\.(ts|js)$/.test(appPath)) {
            appPath = "./" + appPath; // not installed as bin.
            var parsedPath = path_1.parse(appPath);
            completionsDir = parsedPath.dir; // store completions.sh at executable file path.
        }
        var bashPath = !/^win/.test(env.PLATFORM) ? /^darwin/.test(env.PLATFORM) ? '.bash_profile' : '.bashrc' : false;
        if (bashPath)
            bashPath = path_1.join(env.HOME_PATH, bashPath);
        var completionsPath = path_1.join(completionsDir, 'completions.sh');
        return {
            appName: appName,
            appPath: appPath,
            bashPath: bashPath,
            completionsDir: completionsDir,
            completionsPath: completionsPath // the completions path.
        };
    }
    /**
     * Generate
     * : Generates the completions.sh script.
     *
     * @param path the optional executable path.
     * @param command the optional reply command for completions.
     * @param template a custom template for generating completions.
     */
    function generate(path, command, template) {
        var paths = getPaths(path);
        template = template || fs_1.readFileSync(// read in our script template.
        path_1.resolve(constants_1.PARGV_ROOT, 'completion.sh.tpl'), 'utf-8');
        template = template.replace(/{{app_name}}/g, paths.appName); // replace app name.
        template = template.replace(/{{app_reply_command}}/g, command); // replace the command.
        var script = template.replace(/{{app_path}}/g, paths.appPath); // replace the path.
        var sourceScript = srcTpl;
        sourceScript = sourceScript.replace(/{{app_name}}/g, paths.appName);
        sourceScript = sourceScript.replace(/{{app_completions_path}}/g, paths.completionsPath);
        return {
            paths: paths,
            command: command,
            script: script,
            sourceScript: sourceScript
        };
    }
    /**
     * Ensure Dir
     * : Ensures the directory where completions.sh will be stored exists.
     * If it does not it creates it.
     *
     * @param dir the directory where the completions.sh file will be saved.
     */
    function ensureDir(dir) {
        try {
            if (!fs_1.existsSync(dir))
                fs_1.mkdirSync(dir);
            return true;
        }
        catch (ex) {
            return false;
        }
    }
    /**
     * Write
     * : Writes or appends script to file.
     *
     * @param path the path to write or append to.
     * @param script the script to be written or appended.
     * @param append when true append instead of write.
     */
    function write(path, script, append) {
        try {
            if (append)
                fs_1.appendFileSync(path, script, 'utf-8');
            else
                fs_1.writeFileSync(path, script, 'utf-8');
            return true;
        }
        catch (ex) {
            return false;
        }
    }
    /**
     * Install
     * : Installs tab completions.sh and appends to bash.
     *
     * @param path the installation path typically generated by Pargv.
     * @param command an optional reply command name.
     * @param template the optional completions.sh template.
     * @param force when true ignore existing install and overwrites.
     */
    function install(path, command, template, force) {
        var gen = generate(path, command, template); // generate script and paths.
        if (fs_1.existsSync(gen.paths.completionsPath) && force !== true) {
            pargv.error(pargv._localize("completions already installed at %s, use --force to reinstall.")
                .args(gen.paths.completionsPath)
                .styles(colors.accent)
                .done());
            return;
        }
        if (!gen.paths.bashPath) {
            pargv.error(pargv._localize("\"cannot automatically install completions on platform %s.")
                .args(pargv._env.PLATFORM)
                .styles(colors.accent)
                .done());
            return;
        }
        var tmp = true;
        if (ensureDir(gen.paths.completionsDir)) {
            if (write(gen.paths.completionsPath, gen.script)) {
                // const source = `source ${gen.paths.completionsPath}`;
                if (write(gen.paths.bashPath, gen.sourceScript, true)) {
                    return gen; // return the successful configuration.
                }
                else {
                    pargv.error(pargv._localize("could not write, append or create path %s.")
                        .args(gen.paths.bashPath)
                        .styles(colors.accent)
                        .done());
                }
            }
            else {
                pargv.error(pargv._localize("could not write, append or create path %s.")
                    .args(gen.paths.completionsPath)
                    .styles(colors.accent)
                    .done());
            }
        }
        else {
            pargv.error(pargv._localize("could not write, append or create path %s.")
                .args(gen.paths.completionsDir)
                .styles(colors.accent)
                .done());
        }
        return false; // return false to indicate install failed.
    }
    /**
     * Handler
     * : The completions handler returning found completions.
     *
     * @param current the current arg in the terminal
     * @param args the argv array.
     */
    function handler(current, argv) {
        var cmds = pargv._commands;
        var completions = [];
        if (pargv._env.EXEC === argv[0])
            argv.shift(); // remove first arg which is app/exec name.
        var tmpCmd = pargv.get.command(utils.first(argv)); // is first is known command.
        if (tmpCmd) {
            cmds = {}; // set the commands to just the one known command.
            cmds[tmpCmd._name] = tmpCmd;
            var sliced_1 = argv.slice(1); // remove command name.
            var curCmdIdx_1 = 0;
            var lastCmdIdx_1 = tmpCmd._commands.length - 1; // last index for commands.
            sliced_1.forEach(function (el, i) {
                if (!constants_1.FLAG_EXP.test(el) && i <= lastCmdIdx_1) {
                    var prev_1 = sliced_1[i - 1] || null;
                    var prevKey = tmpCmd.isOption(prev_1);
                    if (!prevKey && !constants_1.FLAG_EXP.test(prev_1))
                        curCmdIdx_1 = i;
                }
            });
            var curIdx = sliced_1.length - 1;
            var prevIdx = sliced_1.length - 2;
            var prev = sliced_1[prevIdx] || null;
            var isFlagPrev = prev && constants_1.FLAG_EXP.test(prev);
            var isBool = tmpCmd.isBool(prev);
            var isOption = isFlagPrev && !isBool;
            var isCommand = (curCmdIdx_1 >= 0) &&
                (curCmdIdx_1 <= lastCmdIdx_1);
            //  !FLAG_EXP.test(sliced[curIdx])
            if (isCommand || isOption) {
                var key = isOption ? tmpCmd.aliasToKey(prev) : tmpCmd.aliasToKey(curCmdIdx_1);
                if (tmpCmd._completions[key])
                    completions = completions.concat(tmpCmd._completions[key]);
            }
            if (tmpCmd._completions['*'])
                completions = completions.concat(tmpCmd._completions['*']);
        }
        var _loop_1 = function (k) {
            var cmd = cmds[k];
            [cmd._name].concat(cmd.aliases(cmd._name) || []) // iterate commands.
                .forEach(function (el, i) {
                if (!~completions.indexOf(el))
                    completions.push(el);
            });
            cmd._options.forEach(function (o) {
                if (!~completions.indexOf(o))
                    completions.push(o);
                (cmd.aliases(o) || []).forEach(function (el) {
                    if (!~completions.indexOf(el))
                        completions.push(el);
                });
            });
        };
        for (var k in cmds) {
            _loop_1(k);
        }
        return completions;
    }
    return {
        getPaths: getPaths,
        generate: generate,
        ensureDir: ensureDir,
        write: write,
        install: install,
        handler: handler
    };
}
exports.completions = completions;
//# sourceMappingURL=completions.js.map